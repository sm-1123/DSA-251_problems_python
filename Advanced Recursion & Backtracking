----------------------date:02/06/2024-----------------------------------------
P1:Restore IP Addresses[TC:O(3^4),SC:O(n)]
def generateIPAddress(s):
    # Write your code here.
    res = []

    if len(s) > 12:

        return res

    def backtrack(i, dots, curIP):

        if dots == 4 and i == len(s):

            res.append(curIP[:-1])

            return

        if dots > 4:

            return 

        for j in range(i, min(i + 3, len(s))):

            if int(s[i:j+1]) < 256 and (i == j or s[i] != "0"):

                backtrack(j + 1, dots + 1, curIP + s[i:j+1] + ".")

    backtrack(0, 0, "")

    return res
    
    pass

P2:All Possible Permutations - String[TC:O(n!*n),SC:O(n)]
def recurPermut(idx, s, ans):

	if idx == len(s):

		ans.append(''.join(s))

		return

	for i in range(idx, len(s)):

		s[i], s[idx] = s[idx], s[i]

		recurPermut(idx+1, s, ans)

		s[i], s[idx] = s[idx], s[i]

def findPermutations(s):
	# Write your code here.
	string = list(s)

	ans = []

	recurPermut(0, string, ans)

	return ans
-------------------------date:03/06/2024--------------------------------------------------------
P3:Return Subsets Sum to K[TC:O(2^n),SC:O(n)]
def findSubsetsThatSumToK(arr, n, k) :
    # Write your code here.
    res = []

    def backtrack(i, curr, subsetSum):

        if subsetSum == k:

            res.append(curr.copy())

        if i == n:

            return    

        for j in range(i, n):    

            curr.append(arr[j])

            backtrack(j+1, curr, subsetSum + arr[j])

            curr.pop()

    backtrack(0, [], 0)

    return res
P4:Subsequences of String[TC:O(2^N),SC:O(N)]
def subsequences(str):

    res = []

    def solve(i, curr):

        if i == len(str):

            if curr:

                res.append("".join(curr))

            return 

        curr.append(str[i])

        solve(i + 1, curr)

        curr.pop()

        solve(i + 1, curr)

    solve(0,[])

    return res    
    # Write your code here

