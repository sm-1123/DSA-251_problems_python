P1:Check Subset[TC-O(nlogn + mlogm),SC-O(1)]
def checkSubset(arr1, arr2, n, m):
    # Write your code here.    
    arr1.sort()

    arr2.sort()

    i = 0

    j = 0

    while(i < n and  j < m):

        if arr2[j] < arr1[i]:

            return False

        if arr1[i] == arr2[j]:

            i += 1

            j += 1

        else:

            i += 1    

    if j >= m:

        return True            

    pass
P2:LCA of three Nodes[TC:O(N),SC:O(N)]
def helper(root, node1, node2, node3):

    if root is None:

        return None

    if node1 == root.data or node2 == root.data or node3 == root.data:

        return root    

    left = helper(root.left, node1, node2, node3)

    right = helper(root.right, node1, node2, node3)

    if left is None and right is None:

        return None

    if left and right:

        return root

    if left:

        return left

    return right                        


def lcaOfThreeNodes(root, node1, node2, node3):
    
    # Write your code here

    sys.setrecursionlimit(10**6)  

    temp = helper(root, node1, node2, node3)

    if temp:

        return temp.data

    return -1

    pass
P3:Remove BST keys outside the given range[TC:O(N),SC:O(H)]
def removeOutsideRange(root, min, max):
    # write yout code here
    if root is None:

        return None

    root.left = removeOutsideRange(root.left, min, max)

    root.right = removeOutsideRange(root.right, min, max)

    if root.data < min:

        rchild = root.right

        return rchild

    if root.data > max:

        lchild = root.left

        return lchild

    return root
P4:Search In A Row Wise And Column Wise Sorted Matrix[TC:O(N + M),SC:O(1)]
def search(matrix, x):
    # Write your code here.
    n = len(matrix[0])

    i, j = 0, n - 1

    while i < n and j >= 0:

        if matrix[i][j] == x:

            return [i, j]

        elif matrix[i][j] < x:

            i += 1    

        else:

            j -= 1

    return [-1,-1] 

    pass
P5:Palindrome Linked List[TC:O(N),SC:O(1)]
def isPalindrome(head):
    
    # Write your code here.
    def reversed_ll(node):

        prev = None

        while node:

            temp = node.next

            node.next = prev

            prev = node

            node = temp

        return prev    

    slow = head

    fast = head

    while fast and fast.next:

        slow = slow.next

        fast = fast.next.next

    if fast:

        slow = slow.next

    slow = reversed_ll(slow)

    while slow:

        if head.data != slow.data:

            return False

        slow = slow.next

        head = head.next

    return True        
P6:BST Iterator
class BSTiterator:[TC:O(1),SC:O(H)]
    def __init__(self, root):
        # Complete the constructor function
        self.stk = []

        while root:

            self.stk.append(root)

            root = root.left

        pass

    def next(self):
        # Complete the functiom
        res = self.stk.pop()   

        curr = res.right

        while curr:

            self.stk.append(curr)

            curr = curr.left

        return res.data

        pass

    def hasNext(self):
        # Complete the function
        return self.stk != []
----------------------------------------------------DATE:22/05/2024---------------------------------------------------------
P7:Flatten Binary Tree to Linked List[TC:O(N),SC:O(1)]
def flattenBinaryTree(root):
    # Write your code here.
    curr = root

    while(curr):

        if curr.left:

            prev = curr.left

            while(prev.right):

                prev = prev.right

            prev.right = curr.right

            curr.right = curr.left

        curr = curr.right        

    return root    

P8:Rearrange Linked List[TC:O(N),SC:O(1)]
def rearrangeList(head):
    # Write your code here.
    if not head or not head.next:

        return head    

    def reversed_ll(node):

        prev = None

        while node:

            temp = node.next

            node.next = prev

            prev = node

            node = temp

        return prev

    slow, fast = head, head

    while fast and fast.next:

        slow = slow.next

        fast = fast.next.next

    node2 = reversed_ll(slow.next)

    slow.next = None

    node1 = head

    dummy = Node(0)

    curr = dummy

    while(node1 or node2):

        if node1:

            curr.next = node1

            curr = curr.next

            node1 = node1.next

        if node2:

            curr.next = node2

            curr = curr.next

            node2 = node2.next             

    return dummy.next
    
    pass

P9: Sorted Linked List to Balanced BST[TC:O(N), SC:O(N)]
def fnc(arr, l, r):

	if l > r:

		return None

	mid = (l + r)//2

	node = Node(arr[mid])

	node.left = fnc(arr, l, mid - 1)

	node.right = fnc(arr, mid + 1, r)

	return node	

def sortedListToBST(head):

	arr = []

	while head:

		arr.append(head.data)

		head = head.next

	return fnc(arr, 0, len(arr) - 1)



	''' 
		Write your code here
		Return the root of balanced BST
		Verdict: 'CORRECT' or 'INCORRECT'
	'''
	pass
----------------------------date:23/5/2024--------------------------------------------------------
P10:Merge Two BSTs[TC:O(M + N),SC:O(log(M + N)]
def inOrder(root, bst):

    if root is None:

        return

    inOrder(root.left, bst)

    bst.append(root.data)

    inOrder(root.right, bst)            

def mergeArrays(a, b):

    i, j = 0, 0

    ans = []

    while i < len(a) and j < len(b):

        if a[i] < b[j]:

            ans.append(a[i])

            i += 1

        else:

            ans.append(b[j])

            j += 1

    while i < len(a):

        ans.append(a[i])

        i += 1

    while j < len(b):

        ans.append(b[j])

        j += 1

    return ans    

def buildBst(nums, start, end):

    if start > end:

        return

    mid = (start + end)//2

    root = TreeNode(nums[mid])

    root.left = buildBst(nums, start, mid - 1)

    root.right = buildBst(nums, mid + 1, end)

    return root    

def mergeBST(root1, root2):
	# Write your code here.
    bst1 = []

    bst2 = []

    inOrder(root1, bst1)

    inOrder(root2, bst2)

    mergeSort = mergeArrays(bst1, bst2)

    return buildBst(mergeSort, 0, len(mergeSort) - 1)

P11:Merge Two Binary Trees[TC:O(N),SC:O(N)]
def mergeTrees(root1, root2):
    # Write your code here.
    if root1 == None:

        return root2

    if root2 == None:

        return root1

    root1.data = root1.data + root2.data

    root1.left = mergeTrees(root1.left, root2.left)

    root1.right = mergeTrees(root1.right, root2.right)

    return root1

--------------------------------date:24/05/2024---------------------------------------------
P12:Sort a Stack[TC:O(N^2),SC: O(N)]------Try again
def insert_correct_position(x, stack):

    if len(stack) == 0 or stack[-1] < x:

        stack.append(x)

    else:

        a = stack[-1]

        stack.pop()

        insert_correct_position(x, stack)

        stack.append(a)    

def reverse(stack):

    if len(stack) > 0:

        x = stack[-1]

        stack.pop()

        reverse(stack)

        insert_correct_position(x, stack)



def sortStack(stack):

    reverse(stack)
	

    

